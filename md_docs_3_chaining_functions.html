<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fp: Chaining functions that return Result&lt;T&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fp
   </div>
   <div id="projectbrief">FP (Functional Programming) extensions for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Chaining functions that return Result&lt;T&gt; </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial you'll learn to chain the result of functions that return a <code>Result&lt;T&gt;</code> into a result.</p>
<h1><a class="anchor" id="autotoc_md50"></a>
Example Functions</h1>
<p>Here are two example functions for use in this tutorial.</p>
<div class="fragment"><div class="line">Result&lt;int&gt; convert_small_values(<span class="keywordtype">double</span> x) {</div>
<div class="line">  <span class="keywordflow">if</span> (x &gt; 10.0)</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacetl.html#a01de1a0282a693451af969f35e88bcf9">tl::make_unexpected</a>(<a class="code" href="namespacefp.html#a2decaf550bd0e7811f5fe7ce850b1ded">fp::OutOfRange</a>(fp::format(<span class="stringliteral">&quot;{} &gt; 10&quot;</span>, x)));</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(x);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Result&lt;double&gt; square_positive(<span class="keywordtype">double</span> x) {</div>
<div class="line">  <span class="keywordflow">if</span> (x &lt; 0)</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacetl.html#a01de1a0282a693451af969f35e88bcf9">tl::make_unexpected</a>(<a class="code" href="namespacefp.html#a2decaf550bd0e7811f5fe7ce850b1ded">fp::OutOfRange</a>(fp::format(<span class="stringliteral">&quot;{} &lt; 0&quot;</span>, x)));</div>
<div class="line">  <span class="keywordflow">return</span> x * x;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md51"></a>
The monadic bind function</h1>
<p>This library contains a function that enables you to chain calls together. It does this by taking an input <code>Result&lt;T1&gt;</code> and a function that takes an argument of type <code>T1</code> and returns a result of the type <code>Result&lt;T2&gt;</code> where that is the return type of the function.</p>
<div class="fragment"><div class="line">mbind     : (Result&lt;T1&gt;, T1 → Result&lt;T2&gt;) → Result&lt;T2&gt;</div>
</div><!-- fragment --><p>If the passed in <code>Result&lt;T1&gt;</code> is an error it stores that error in the return type <code>Result&lt;T2&gt;</code>. If the passed in <code>Result&lt;T1&gt;</code> contains a value it calls the function that you passed in and returns it's result. Here is an example of how you could use it to call the two example functions.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result</div>
<div class="line">  = <a class="code" href="namespacefp.html#afbeecf9dbdf9b3c9e6bfaab97c06fc97">fp::mbind</a>(</div>
<div class="line">      <a class="code" href="namespacefp.html#afbeecf9dbdf9b3c9e6bfaab97c06fc97">fp::mbind</a>(<a class="code" href="namespacefp.html#ab858d18687924bd9947f25d5de916edb">fp::make_result</a>(2), square_positive),</div>
<div class="line">      convert_small_values</div>
<div class="line">    );</div>
</div><!-- fragment --><p>This will first calculate the result of <code>square_positive(2)</code> and then the result of that (if successful) will be sent to the second function <code>convert_small_values</code>.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
The operator| overload</h1>
<p>This syntax is rather cumbersome so we have implemented an overload for the <code>operator|</code> that makes it using it much nicer. This creates syntax that resembles the shell pipe syntax where one operation is chained into the next if it succeeds.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = <a class="code" href="namespacefp.html#ab858d18687924bd9947f25d5de916edb">fp::make_result</a>(2) | square_positive | convert_small_values;</div>
</div><!-- fragment --><p>Aternatively you can call the first function instead of using the <code><a class="el" href="namespacefp.html#ab858d18687924bd9947f25d5de916edb" title="Makes a Result&lt;T&gt; from a T value.">fp::make_result</a></code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = square_positive(2) | convert_small_values;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md53"></a>
The FP extensions from tl::expected</h1>
<p>Because the <code>Result&lt;T&gt;</code> type is just an alias for <code><a class="el" href="classtl_1_1expected.html">tl::expected</a>&lt;T, Error&gt;</code> you can use the interface of <code><a class="el" href="classtl_1_1expected.html">tl::expected</a>&lt;T, E&gt;</code> to chain calls. The five functions are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">has_value </td><td class="markdownTableBodyNone">Returns whether or not *this is in the expected state.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">value_or </td><td class="markdownTableBodyNone">If *this is in the expected state, returns the expected value. Otherwise returns u.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">and_then </td><td class="markdownTableBodyNone">Used to compose functions which return a <a class="el" href="classtl_1_1expected.html">tl::expected</a>. If *this is in the expected state, applies f to the expected value and returns the result. Otherwise returns *this (i.e. the unexpected value bubbles up). Requires: Calling the given function with the expected value must return a specialization of <a class="el" href="classtl_1_1expected.html">tl::expected</a>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">map </td><td class="markdownTableBodyNone">Apply a function to change the expected value (and possibly the type). If *this is in the expected state, applies f to the expected value and returns the result wrapped in a tl::expected&lt;ResultType, E&gt;. Otherwise returns *this (i.e. the unexpected value bubbles up).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transform </td><td class="markdownTableBodyNone">Alias for map.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">map_error </td><td class="markdownTableBodyNone">Apply a function to change the unexpected value (and possibly the type). If *this is in the unexpected state, applies f to the unexpected value and returns the result wrapped in a tl::expected&lt;T, ResultType&gt;. Otherwise returns *this (i.e. the expected value bubbles up).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">or_else </td><td class="markdownTableBodyNone">If *this is in the unexpected state, calls f(this-&gt;error()) and returns the result. Otherwise returns *this. Requires: std::invoke_result_t&lt;F&gt; must be void or convertible to tl::expected&lt;T,E&gt;.  </td></tr>
</table>
<p><a href="https://tl.tartanllama.xyz/en/latest/api/expected.html#_CPPv4I0ENKR8expected8value_orE1TRR1U">See the full API documentation for these functions here.</a></p>
<p>An example of using <code>and_then</code> to do the same thing as above.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = square_positive(2).and_then(convert_small_values);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md54"></a>
Reasining about computations without values</h1>
<p>A final thing that you might want to do is construct a function that combines calling various functions in sequence. To make this easier we've implemented the <code>mcompose</code> function that takes n number of functions that chain together and constructs a function that represents the result of calling them in order.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> constexpr launch_satelite = <a class="code" href="namespacefp.html#a9b1050477e7a529d7ae3c2e1e8cc2296">mcompose</a>(</div>
<div class="line">  build_rocket,</div>
<div class="line">  insert_satelite,</div>
<div class="line">  tranport_to_launch_pad,</div>
<div class="line">  launch,</div>
<div class="line">  recover_rocket,</div>
<div class="line">  verify_satelite_in_orbit);</div>
</div><!-- fragment --><p>Then later you could use this function like this:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = launch_satelite(SpaceCamera{});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md55"></a>
Summary</h1>
<p>In this tutorial we learned how to chain calls to functions that can fail and how we can chain those functions into a resulting function we could call. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespacetl_html_a01de1a0282a693451af969f35e88bcf9"><div class="ttname"><a href="namespacetl.html#a01de1a0282a693451af969f35e88bcf9">tl::make_unexpected</a></div><div class="ttdeci">unexpected&lt; typename std::decay&lt; E &gt;::type &gt; make_unexpected(E &amp;&amp;e)</div><div class="ttdef"><b>Definition:</b> <a href="expected_8hpp_source.html#l00178">expected.hpp:178</a></div></div>
<div class="ttc" id="anamespacefp_html_ab858d18687924bd9947f25d5de916edb"><div class="ttname"><a href="namespacefp.html#ab858d18687924bd9947f25d5de916edb">fp::make_result</a></div><div class="ttdeci">constexpr Result&lt; T &gt; make_result(T value)</div><div class="ttdoc">Makes a Result&lt;T&gt; from a T value.</div><div class="ttdef"><b>Definition:</b> <a href="result_8hpp_source.html#l00199">result.hpp:199</a></div></div>
<div class="ttc" id="anamespacefp_html_a2decaf550bd0e7811f5fe7ce850b1ded"><div class="ttname"><a href="namespacefp.html#a2decaf550bd0e7811f5fe7ce850b1ded">fp::OutOfRange</a></div><div class="ttdeci">constexpr auto OutOfRange</div><div class="ttdef"><b>Definition:</b> <a href="result_8hpp_source.html#l00113">result.hpp:113</a></div></div>
<div class="ttc" id="anamespacefp_html_a9b1050477e7a529d7ae3c2e1e8cc2296"><div class="ttname"><a href="namespacefp.html#a9b1050477e7a529d7ae3c2e1e8cc2296">fp::mcompose</a></div><div class="ttdeci">constexpr auto mcompose(F f, G g)</div><div class="ttdoc">Monadic compose two monad functions.</div><div class="ttdef"><b>Definition:</b> <a href="monad_8hpp_source.html#l00128">monad.hpp:128</a></div></div>
<div class="ttc" id="anamespacefp_html_afbeecf9dbdf9b3c9e6bfaab97c06fc97"><div class="ttname"><a href="namespacefp.html#afbeecf9dbdf9b3c9e6bfaab97c06fc97">fp::mbind</a></div><div class="ttdeci">constexpr auto mbind(const std::optional&lt; T &gt; &amp;opt, F f) -&gt; decltype(f(opt.value()))</div><div class="ttdoc">Monad optional bind.</div><div class="ttdef"><b>Definition:</b> <a href="monad_8hpp_source.html#l00063">monad.hpp:63</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
